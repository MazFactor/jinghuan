---
layout: post
title: Java基础-IO
categories: Java
description: Java IO
keywords: IO
---
计算机中运算和存储的数据最小单位是位（bit），它的值只可能是0或者1。但1 bit 的信息量太少了。要表示一个有用的信息，需要好几个bit一起表示。所以除了硬件层面存在1个比特位的寄存器，大多数情况下，**字节（byte）是数据最小的基本单位**。

计算机中的数据分为两类：数值类型和非数值类型

Java语言提供了八种基本类型。六种数值类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。其中整型、浮点型、布尔型都是以二井制形式存储，而字符型则需要通过编码转换为二进制进行存储。详见另外一篇文章[计算机的基础数据类型](https://www.cnblogs.com/yilang/p/11139380.html)。

### 编码
#### 概念
编码，又称代码，是用预先规定的方法，将文字、数字或其他对象编成数码，或将信息、数据转换成规定的电脉冲信号。它在电子计算机、电视遥控和通讯等方面广泛使用。

在电子计算机中，将指令和数字实行编码后，适合计算机运行和操作。编码作为计算机书写指令的过程，是程序设计活动的一部分。在数字磁记录中，可按照一定的规则，进行输入信息序列向编码序列的过程转换。在遥控系统和通信系统中，采用编码步骤可提高传送的效率和可靠性。

将数据转换为编码字符，必要时又可编码成原来的数据形式。

#### ASCII
原本对于西方世界来讲，可能根本用不到“字符”这个东西。1个字节就解决全部问题了。因为一个字节8 bit，最多为&=个符号编码。英语26个字母，再加几个常用符号，标点，256个码位足够了。这就熟悉的**ASCII码**。如下图，ASCII码一共收录了空格及94个“可印刷字符”。每个字母或标点占一个字节。简简单单一个表，就把所有编码都解决了。

![ASCII码表]({{assets_base_url}}/images/blog/Java基础/IO/ASCII码表.jpg)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">ASCII码表</div>
</center>

#### ISO/IEC 8859-1
但西方世界不光只有英语一门语言。什么德语，法语，西班牙语都有自己的特殊字母。但这也没什么大不了的。每个国家都可以定义属于自己语言的特殊编码标准，而且大小照样不超过256。因为ASCII码中本身就有很多空码位没有使用。比如**ISO/IEC 8859-n**系就是国际标准化组织定义的一系列8位字符集。其中最常见的**ISO/IEC 8859-1**就是法语，芬兰语所用的西欧字符集。也是每个字母或符号用1个字节表示，下面这张表解决战斗。

![ISO IEC 8859-1]({{assets_base_url}}/images/blog/Java基础/IO/ISO IEC 8859-1.jpg)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">ISO IEC 8859-1</div>
</center>

#### 中文编码
但26个字母到了中文，日语，韩语为代表的东亚象形文字面前就太小儿科了。汉字少说也有十万个。别说是8 bit，就算是16 bit（2^16&=65536）也不一定够。如果说一个汉字代表一个“字符”，从这个时候开始，“字符”的概念开始凌驾于“字节”之上了。收到的每一个字节不能简单地解码成一个字母了，而是需要好几个字节组合成一个“汉字”。我国的汉字编码现行标准是GB18030，每个字可以由1个、2个或4个字节组成，编码空间有161万个字符。另一个中国常用编码集是Big5。

#### Unicode
在出现Unicode之前，几乎每一种文字都有一套自己的编码方式。同一段“字节流”，在美帝可能是"hello world"，到我们天朝就变成“锟斤拷” ，“烫烫烫”了。所以“Unicode”可谓大势所趋。它的理念非常简单：全世界每个不同语言的不同字符都统一编码，全球通行。最初，每个字符占用2个字节，总共2^16&=65536个字符空间。比如，下面是“中国”两个字的Unicode代码。从第四版开始加入的“扩展字符集”开始使用4个字节（32 bit）编码。目前Unicode收录的字符规模大概在12万左右。

> 中 $\Rightarrow$ 4e2d 000d<br>
> 国 $\Rightarrow$ 000a 56fd

#### UTF-16
编码里最容易搞混的一件事就是：Unicode只是一套符号的编码。但计算机具体怎么读取这套编码，又是另外一件事。

比如既然Unicode常规字符集占用2个字节，系统可以每次老老实实读取两个字节。然后用一个特殊符号告诉系统某个字符属于附加字符集，需要再往后读2个字节。比如说Java系统默认的UTF-16就是就是这样编码解码的：

考虑下面这句话：

> I am 君山

![I am 君山]({{assets_base_url}}/images/blog/Java基础/IO/I am 君山.jpg)

Unicode字符集中：

> 君=541b。拆开存在两个字节里：“54”和“1b”。
> 山=5c71。拆开存在两个字节里：“5c”和“71”。

是不是很朴素？

#### UTF-8
但上面UTF-16的缺点也很明显：就是所有英语字符“I am”也被迫用2个字节来编码。比如，

> I=49。在前面补零变成：“00”和“49”。

考虑到英语是使用最广泛的语言，用2个字节为1字节信息编码，浪费了内存空间。最好是让英语保持ASCII的编码，用1个字节，汉字等其他字符才用2个或更长的字节表示。这里就涉及到一个技术问题：怎么让系统知道一个字符是用1个还是2个还是3个字节编码的呢？这就是UTF-8做的事。

如下图所示，这里UTF-8可变长编码用到了一个小技巧：用几位冗余信息告诉系统，当前字符有没有结束，是不是还需要继续往下读下一个字节。

![UTF-8]({{assets_base_url}}/images/blog/Java基础/IO/UTF-8.png)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">UTF-8</div>
</center>

可以看到如果一个字节是以“0”开头的，说明是一个ASCII字符，只占一个字节。如果是“11”开头的，说明这个字符占用多个字节。后续每个“10”打头的字节都是这个字符的一部分。

下图演示了字符串“I am 君山”用 UTF-8 编码的结果：

![演变结果]({{assets_base_url}}/images/blog/Java基础/IO/演变结果.jpg)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">演变结果</div>
</center>

> 君 = 541b = 0101 0100 0001 1011 (Unicode)

需要用3个字节编码，把0101010000011011切成3部分变成：

> 0101 010000 011011 

分别套上UTF-8字符头：

> 1110 0101 10 010000 10 011011 = e5 90 9b

所以如上图所示，“君”字用UTF-8编码就成了：e5909b。

总而言之，一切都是字节流，其实没有字符流这个东西。字符只是根据编码集对字节流翻译之后的产物。

### Java I/O的编码系统
Java IO库有两个支系：

* 面向字节流的**InputStream**和**OutputStream**
* 面向字符的**Reader**和**Writer**

之前说了，字节流的InputStream和OutputStream是一切的基础。实际总线中流动的只有字节流。需要对字节流做特殊解码才能得到字符流。Java中负责从字节流向字符流解码的桥梁是：**InputStreamReader**和**OutputStreamWriter**

根据上面的编码规则，Reader返回的是一个解码后的Unicode码元。包装在一个int整型里返回。

```java
abstract int read();
```

也就是收到3个字节后，去掉UTF-8报头，拼装起来得到“君”字的Unicode码元。

> 1110 0101 10 010000 10 011011 $\Rightarrow$ 0101 0100 0001 1011

然后包装在4个字节的int整型里返回：

> 0101 0100 0001 1011 $\Rightarrow$ 0000 0000 0000 0000 0101 0100 0001 1011

write()方法是一个相反的编码过程：

```java
abstract void write(int c);
```

输入一个Unicode码元的int型，如果设定编码是UTF-8，内部会自动切割并添加报头。

以下是InputStreamReader和OutputStreamWriter的结构图：

![InputStreamReader和OutputStreamWriter类结构]({{assets_base_url}}/images/blog/Java基础/IO/InputStreamReader和OutputStreamWriter类结构.png)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">InputStreamReader和OutputStreamWriter类结构</div>
</center>

从图中可以猜到，实际负责编码和解码的是StreamDecoder类和StreamEncoder类。过程中必须指定使用的字符编码集Charset。所以InputStreamReader和OutputStreamWriter的构造器都带有Charset类型的参数。

> **InputStreamReader**(InputStream in, Charset cs)
> **OutputStreamWriter**(OutputStream out, Charset cs)

如果没有指定编码集，将使用系统默认编码集。而我们经常使用的FileInputReader和FileOutputWriter就是InputStreamReader和OutputStreamWriter的派生类。

#### 内存String编码
另外一个要使用到Charset编码集的地方，是String的构造器和getBytes()方法。也可以通过参数控制具体使用的编码集。

```java
String s = "这是一段中文字符串"; 
byte[] b = s.getBytes("UTF-8"); 
String n = new String(b,"UTF-8");
```

#### nio的字符编码
另外nio包里的ByteBuffer的asCharBuffer()方法也可以实现字节流和字符流之间的转换。

```java
FileChannel fc=new FileInputStream(f).getChannel();
ByteBuffer bf=ByteBuffer.allocate(1024);
fc.read(bf);
bf.flip();
CharBuffer cf=bf.asCharBuffer();
```

但这里有个坑需要注意，asCharBuffer()方法，默认以UTF-16BE来解码byteBuffer里的字节。每个字符2字节。而String # getBytes()使用系统默认编码方式，大多数情况都不是UTF-16BE。所以经常CharBuffer里读取出来的会是乱码。










初学Java一直搞不懂I/O及里面各种类的关系，加之I/O类库采用了装饰器模式开发实现的原因，用于处理I/O的类多且杂。使用装饰器模式的好处就是它提供相当大的灵活性，用于处理各种I/O的情况，但同时也增加了代码的复杂性。所以初学者很容易被众多繁杂且功能各异的I/O类搞得晕头转向。接下来我们以I/O需要处理的各种数据类型及情况为出发点，从JDK1.0到目前最流行的I/O框架，逐步详细地介绍一下Java I/O的整体和细节实现，死磕到底。

关于装饰器模式可以参考我的另外一篇文章[Java之装饰器模式](http://#)，对该模式的理解有助于我们更好地理解本章内容。

计算机设计出来的目的无非是处理数据，计算机本身只是一个工具而已。当然语言也是，不管是低级语言还是高级语言，其最终目的还是对数据进行处理、加工、搬运、展现……等等。准确地说Java中的I/O类库的功能则主要是对数据进行搬运，即将数据从一个地方（数据源）移至另外一个地方（目的源），当然这中间过程中可以涉及一些数据格式的转换操作，其目的也是为了方便传输或存储。

Java中数据的来源可以有多种形式，包括字节数组、String对象、文件、“管道”（工作方式与实际管道相似，即，从一端输入，从另一端输出）、一个由其他各类的流组成的序列（以便我们可以将它们收集合并到一个流内）、其他数据源（如Internet连接等）。

各类繁杂，数量众多的数据源进到Java程序中，又从Java程序中出去，用一个很形象的比喻即为“流”。从而也体现了Java对数据的处理是一个动态的过程。所以在Java中我们将数据抽象成为“流”，即Stream。

从流的方向来区分可以将流分为输入流和输出流：<br>
输入流：程序可以从中读取数据的流，可以是计算机或外围设备，甚至是程序本身所占据内存对应的某个数组或对象。<br>
输出流：程序能向其写入数据的流，也可以可以是计算机或外围设备，甚至是程序本身所占据内存对应的某个数组或对象。

数据在计算机或外围设备中存在以（字节、字符）可以分为字节流和字符流：<br>


I/O模块或者说各种I/O类的目的无非是将数据从一个地方拿来，依据需要进行处理、加工，然后放到另一个地方（也可能是放加原处）。所以

### 一、概述
Java是一种面向对象语言，如果我们要针对多个对象进行操作，就必须对多个对象进行存储。而数组长度固定，不能满足变化的要求。所以，java提供了集合。

特点

    1.长度可以发生改变
    2.只能存储对象
    3.可以存储多种类型对象

与数组区别

||数组|集合|
|:----:|:----:|:----:|
|**长度**|固定|可变|
|**存储元素**|基本类型/引用类型|引用类型|
|**元素类型的一致性**|必须一致|可以不一致|

### 二、集合体系
集合作为一个容器，可以存储多个元素，但是由于数据结构的不同，java提供了多种集合类。将集合类中共性的功能，不断向上抽取，最终形成了集合体系结构。

数据结构：数据存储的方式

Java中集合类的关系图：

![Java中集合类的关系图]({{assets_base_url}}/images/blog/Java基础/集合/Java中集合类的关系图.jpg)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">Java中集合类的关系图</div>
</center>

Java中集合类完整关系图：

![Java中集合类完整关系图]({{assets_base_url}}/images/blog/Java基础/集合/Java集合关系完整图解.png)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">Java中集合类完整关系图</div>
</center>

Java中集合类的分类及特性：

![Java中集合类的分类及特性]({{assets_base_url}}/images/blog/Java基础/集合/Java中集合类的分类及特性.jpg)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">Java中集合类的分类及特性</div>
</center>

### 三、Collection
Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行，于是衍生出两个子类接口List和Set。

![Collection体系]({{assets_base_url}}/images/blog/Java基础/集合/Collection体系.png)
<center>
<div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">Collection体系</div>
</center>

#### Collection基本功能

A:添加功能

    boolean add(Object obj):向集合中添加一个元素

    boolean addAll(Collection c)：向集合中添加一个集合的元素。

B:删除功能

    void clear()：删除集合中的所有元素。

    boolean remove(Object obj)：从集合中删除指定的元素

    boolean removeAll(Collection c):从集合中删除一个指定的集合元素。

C:判断功能

    boolean isEmpty()：判断集合是否为空。

    boolean contains(Object obj)：判断集合中是否存在指定的元素。

    boolean containsAll(Collection c)：判断集合中是否存在指定的一个集合中的元素。

D:遍历功能

    Iterator iterator():就是用来获取集合中每一个元素。

E:长度功能

    int size():获取集合中的元素个数

F:交集功能

    boolean retainAll(Collection c):判断两个集合中是否有相同的元素。???

G:把集合转换成数组

    Object[] toArray():把集合变成数组。

#### List接口
List接口下的集合元素存储有序，可以重复

A:添加功能

    void add(int index, Object obj):在指定位置添加元素


B:删除功能

    Object remove(int index):根据指定索引删除元素，并把删除的元素返回。

C:修改功能

    Object set(int index, Object obj):把指定索引位置的元素修改为指定的值，返回修改前的值。

D:获取功能

    int indexOf(Object o):返回指定元素在集合中第一次出现的索引

    Object get(int index):获取指定位置的元素

    ListIterator listIterator()：列表迭代器

E:截取功能

    List subList(int fromIndex, int toIndex)：截取集合。

#### Set 接口
Set接口下的元素无序，不可以重复。其下面分为HashSet和TreeSet。

**HashSet**
底层数据结构是哈希表，线程不安全，效率高。

    保证唯一性依赖两个方法：hashCode()和equals()。

        逻辑：
        判断hashCode()值是否相同。

        相同：继续走equals(),看返回值

            如果true：就不添加到集合。

            如果false：就添加到集合。

        不同：就添加到集合。

**TreeSet**
底层数据结构是二叉树，线程不安全，效率高。

    保证元素唯一性的方法时根据返回值是否是0。

    保证排序的两种方式：

        自然排序（元素具备比较性）：实现Comparable接口

        比较器排序（集合具备比较性）：实现Comparator接口