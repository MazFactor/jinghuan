---
layout: post
title: 深入理解Java虚拟机笔记（三）-Class类文件结构
categories: Java虚拟机
description: 类文件结构
keywords: Java虚拟机 类文件结构
---
### 概述
Class文件是一组以字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用单个字节以上的空间的数据项时，则会按照高位在前的方式分割成若干个字节进行存储。

### 数据类型
Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。无符号数属于基本的数据类型。表是同多个无符号数或者其他表作为数据项构成的复合数据类型。

### 魔数与Class文件的版本
每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。紧接着魔数的4个字节存储的是Class文件的版本号，其中第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。

### 常量池
紧接着主、次版本号之后是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是Class文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。常量池中每一项常量都是一个表。截止JDK13，常量池中分别有17种不同类型的常量。这17类表的表结构起始的第一位都是一个u1类型的标志位（tag），代表着当前常量属于哪种常量类型。

### 访问标志
常量池结束之后，紧接着的2个字节代表访问标志（access_flag），这个标识用于识别一些类或者接口层次的访问信息，包括：这个Class类是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。

### 类索引、父类索引与接口索引集合
类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interface）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。

### 字段表集合
字段表（field info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级别以及实例变量，但不包括在方法内部声明的局部变量。

全限定名：把类全名中的“.”换成“/”即类的全限定名。为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。

简单名称：就是指没有类型和参数修饰的方法或者字段名称。

描述符：相比于全限定名和简单名称，方法和字段的描述符要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符的规则，基本类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。对于数组类型，每一维使用一个前置的“[”来描述，如一个整形数组将被记录成“[I”。用描述符来描述方法时，按照方法先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组上括号“()”之内。如void inc()的描述符为“()V”。

特征签名：是指一个方法中各个参数在常量池中的字段符号引用的集合。由于返回值不会包含在特征签名中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有访求进行重载。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

### 属性表集合
Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。与Class文件中其他项目要求严格不同，属性表不要求各个属性具有严格顺序，但要求属性名不能重复。Java虚拟机运行时会忽略它不认识的属性。

对于每一个属性的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义，只需要通过一个u4长度的属性去说明属性值占用位数即可。

一个符合规则的属性表应该满足以下表中所定义的结构：
|类型|名称|数量|
|:---|:---|:---|
|u2|attribute_name_index|1|
|u4|attribute_length|1|
|u1|info|attribute_lenth|

#### 1.Code属性
Java程序方法里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合中，但接口或者抽象类中的方法不存在Code属性。

Code属性表结构
|类型|名称|数量|
|:----|:----|:----|
|u2|attribute_name_index|1|
|u4|attribute_length|1|
|u2|max_stack|1|
|u2|max_locals|1|
|u4|code_length|1|
|u1|code|code_length|
|u2|exception_table_length|1|
|exception_info|exception_table|exception_table_length|
|u2|attributes_count|1|
|attribute_info|attributes|attributes_count|

<br>
attribute_name_index中一项CONSTANT_Utf8_info类型常量的索引，此常量值固定为“Code”，代表该属性的名称。

attribute_length指示了属性值的长度。

max_stack代表了操作数栈（Operand Stack）尝试的最大值。虚拟机运行要根据这个值来分配栈帧（Stack Frame）中的操作数栈深度。

max_locals代表了局部变量表所需的存储空间。max_locals的单位是变量槽（Slot），即虚拟机为变量分配内存的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要占用两个变量槽。方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理程序的参数（Exception Handler Parameter，即try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。Javac编译器根据变量的作用域来分配变量槽给各个变量，根据同时生存的最大局部变量数量和类型计算出max_locals的值。

code_length和code用来存储Java源程序编译后生成的字节码指令。code是一个u1类型的单字节，对应取值范围为0x00~0xFF，即256条指令。但目前《Java虚拟机规范》定义了其中约200条编码值对应的指令含义，编码与指令之间对应关系见“虚拟机字节码指令表”。关于code_length，因为《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，虽然它的值可以达到2的32次幂，但如果一个方法过长，超过了这个限制，Javac编译器就会拒绝编译。如某些JSP编译器会把JSP内容和页面输出信息归并于一个方法中，就有可能超过这个限制。code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Meteadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件里，Code属性用于描述代码，所有其他数据项目都用于描述数据。

#### 2.其他属性
其他属性还有很多，如Exception属性等，这里不作一一介绍。

<br><br>
至此关于Class文件结构的内容就是这些，下一章中我们继续介绍字节码指令的相关内容。

