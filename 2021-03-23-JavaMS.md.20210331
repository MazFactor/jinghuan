---
layout: post
title: JavaMS
categories: Java
description: JavaMS
keywords: JavaMS
---
### 消息队列
#### 1.消息队列有什么用？
MQ全称为Message Queue，即消息队列（MQ），它是一种应用程序对应用程序的通信方法，通过MQ实现的松耦合架构设计可以提高系统可用性以及可扩展性，是适用于现代应用的最佳设计方案。

消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。

排队指的是应用程序通过队列来通信，队列的使用除去了接收和发送应用程序同时执行的要求。
#### 2.消息队列有哪些应用场景？
消息队列比较核心的应用场景：解耦、异步和消峰。
#### 3.消息队列有什么优缺点？
异步、解耦、消峰填谷这是消息队列最大的优点，除了这些，消息队列还可以会解决一些我们特殊业务场景的问题。

消息队列的缺点主要在于系统的可用性、复杂性、一致性问题，引入消息队列后，需要考虑MQ的可用性，万一MQ崩溃了岂不要爆炸？而且复杂性明显提高，需要考虑一些消息队列的常见问题和解决方案，还有就是一致性问题，一条消息由多个消费者消费，万一有一个消费者消费失败了，就会导致数据不一致。
#### 4.消息队列怎么选型？
主流开源的消息中间件有：Kafka、ActiveMQ、RabbitMQ、RocketMQ，下面是对比：
#### 5.有了多线程，为什么还要消息队列？
（1）用多线程，那服务器的资源消耗还是在本机上，而消息队列可以转移到消费者的服务器上；
（2）多线程限定在具体的编程语言，解决的是编程层面的问题，而消息队列不限定编程语言，解决的是架构层面的问题；
#### 6.消息队列适用场景
1.可靠性要求高时选择消息队列：消息队列和多线程两者并不冲突，多线程可以作为队列的生产者和消费者。使用外部的消息队列时，第一是可以提高应用的稳定性，当程序fail后，已经写入外部消息队列的数据依旧是保存的，如果使用两步commit的队列的话，可以更加提高这个项目。

2.不着急知道结果，尽量使用消息队列，保证服务器的压力减小，因为多线程对cpu的消耗大一点：用线程的话，会占用主服务器资源，消息队列的话，可以放到其他机器上运行，让主服务器尽量多的服务其他请求。我个人认为，如果用户不急着知道结果的操作，用消息队列，否则再考虑用不用线程。

3.需要解耦的时候用消息队列：解耦更充分，架构更合理。多线程是在编程语言层面解决问题，消息队列是在架构层面解决问题。我认为架构层面解决问题是“觉悟比较高的方式”，理想情况下应该限制语言层面滥用多线程，能不用就不用。

4.如果容易出现线程安全问题的业务或者批量操作时，也尽量使用消息队列：批量发送邮件时，数据量庞大，如果使用多线程对系统不安全。
#### 7.使用消息队列会遇到哪些问题？
1.消息丢失<br>
2.消息重复消费<br>
3.消息积压<br>
4.消息顺序问题<br>
5.消息事务问题<br>
等等。。。
#### 8.消息队列如何处理消息重复消费问题？
重复消费通常都是由于网络原因造成的，原因如下：通常消息被成功消费后消费者都会发送一个成功标志给MQ，MQ收到这个标志就表示消息已经成功消费了，就不会再发送给其他消费者了。但是如果因为网络原因这个标志没有送到MQ就丢失了，MQ就认为这个消息没有被成功消费，就会再次发送给其他消费者消费，就造成了重复。

这个问题就变成了我们怎么保证消费端的幂等性。

幂等性需要根据业务需求来具体看，但主要的原理就是去重。一般可分为强校验、弱校验：

* 强校验  一般与金融相关的操作都强校验的，比如消费者是一个打款服务，在付款成功后都加一条流水记录。且两个操作放入一个事务中。再次消费的时候就去流水表查一下有没有这条记录，如果有表示已经消费过了，直接返回。流水表也能起到对账的作用！一些简单的场景也可以依赖数据库唯一约束实现。

* 弱校验  没有那么严格，重复一下也没有那么重要。可以将ID保存在redis set中，过期时间看情况设置。如果ID不能保证唯一可以选择生产方生成一个token存入redis，消费方在消费后将其删除（redis的操作能保证其原子性、删除失败会返回0）。
#### 9.消息队列为什么会产生消息丢失？
消息丢失一般有以下三个场景：

（1）生产者弄丢数据<br>
主流的MQ都有确认机制或者事务机制，可以保证生产者将消息送达到MQ。比如RabbitMQ就有事务模式和confirm模式。

（2）消息队列弄丢数据<br>
一般只要开户MQ的持久化磁盘配置就能解决这个问题。
#### 10.消息队列如何解决消息丢失问题？
消息发送超时，牌不确定状态，导致重试发送消息，有可能之前的消息已经发送成功，会出现消息重复的情况。

解决思路是，每个消息生成一个消息ID，如果发送的消息Broker已经存在，则丢弃。这种解决办法需要维护一个已经接收的消息的message id list。

消息在Broker中只有一份，但是consumer重启前，未及时更新offset，导致consumer重启之后重复消费消息。

上游业务给每个message分配一个message ID，下游业务在接收到message之后，执行业务并保存message ID，而且要将两部分放到同一个事务中，保证业务执行成功，message ID肯定保存，Gotland执行失败，message ID肯定不会保存下来，利用db中存储的message ID来做幂等。我们可以重新封装producer client和consumer client，将这部分message ID分配和判重的逻辑封装到client lib里面。
#### 11.消息队列如何保证消息顺序消费？
顺序消费的场景比如一个电商的下单操作，下单后先减库存然后生成订单，这个操作就需要保证顺序执行：<br>
（1）首先生产者需要保证入队的顺序；<br>
（2）一般的MQ都能保证内部Queue是FIFO（先进先出），但是只是针对一个Queue，所以在发送消息的时候可以使用Hash取模法将同一个操作的消息发送到同一个Queue里面，这样就能保证出队时是顺序的了。<br>
（3）消费者也需要注意，如果多个消费者同时消费一个队列，一样可能出现顺序错乱的情况。